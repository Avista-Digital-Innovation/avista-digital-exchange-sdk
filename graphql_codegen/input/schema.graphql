schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

# # Timestream types
type AWSTimestreamQueryResult {
  clientToken: String
  resultJSONString: String!
}

type AssetAttribute {
  attributeType: MeasureValueType!
  data: [AttributeDataEntry]
  lastValue: String!
  lastValueTime: String!
  name: String!
}

type AttributeDataEntry {
  timestamp: String!
  value: String!
}

type AuthenticationToken {
  # iso8601
  dateCreated: String!
  # iso8601
  dateExpires: String!
  lastActive: String
  name: String!
  scope: [String]
  tokenId: ID!
  # iso8601
  tokenType: AuthenticationTokenType
  tokenValue: String
  userId: ID!
}

type Collaborative {
  collaborativeId: ID!
  description: String
  hostOrganizationId: String!
  memberOrganizations: [CollaborativeMemberOrganization]
  name: String!
}

type CollaborativeMemberOrganization {
  accessApprovedByUserId: ID
  collaborativeId: ID!
  memberState: CollaborativeMemberOrganizationState
  organization: Organization
  submittedByUser: User
  submittedTimestamp: String
  usersInCollaborative: [CollaborativeMemberUser]
}

type CollaborativeMemberUser {
  permission: CollaborativeMemberPermission
  user: User
}

type DataCapture {
  captureId: ID!
  captureType: DataCaptureType!
  dataModel: DataCaptureDataModel
  dateCreated: String!
  dateUpdated: String!
  description: String
  displayName: String!
  ownerUserId: ID!
  state: DataCaptureState!
  stateHistory: [DataCaptureStateChange]
  timeSettings: DataCaptureTimeConfiguration
}

type DataCaptureAsset {
  attributes: [DataCaptureAssetAttribute]
  description: String
  displayName: String!
  userDefinedId: ID!
}

type DataCaptureAssetAttribute {
  attributeType: DataCaptureAssetAttributeType!
  description: String
  displayName: String!
  schemaType: DataCaptureAssetAttributeSchemaType!
  unit: String
  userDefinedId: ID!
}

type DataCaptureAttachment {
  attachmentId: ID!
  attachmentType: DataCaptureAttachmentType!
  dateCreated: String
  dateUpdated: String
  description: String
  error: DataCaptureAttachmentError
  name: String
  ownerUserId: ID!
}

type DataCaptureAttributeDataRecord {
  timestamp: String!
  userDefinedId: ID!
  value: String!
}

type DataCaptureAttributeValue {
  userDefinedId: ID!
  value: String!
}

type DataCaptureDataExport {
  dateCompleted: String
  dateStarted: String
  exportType: DataCaptureDataExportType
  logs: [String]
  name: String
  state: DataCaptureDataExportState!
  url: String
}

type DataCaptureDataModel {
  dateCreated: String
  dateUpdated: String
  errors: [String]
  #  displayName: String
  # description: String
  items: [DataCaptureAsset]!
  state: DataCaptureDataModelState!
  version: Int
}

type DataCaptureDataModelExport {
  captureId: ID!
  contents: String!
  fileName: String!
}

type DataCaptureFailedRecord {
  attributeIndex: Int
  errorType: DataCaptureRecordError!
  message: String
  recordIndex: Int!
}

type DataCapturePublishDataResponse {
  captureId: ID!
  dataWritten: [DataCaptureAttributeDataRecord]
  failedRecords: [DataCaptureFailedRecord]
  logs: [DataCapturePublishLog]
}

type DataCapturePublishLog {
  error: Boolean
  message: String
}

type DataCaptureStateChange {
  dateCreated: String!
  message: String
  newState: DataCaptureState!
}

type DataCaptureTimeConfiguration {
  actualStartTime: String
  actualStopTime: String
  errors: [String]
  scheduledStartTime: String
  scheduledStopTime: String
  startTimeType: DataCaptureTimeConfigType!
  state: DataCaptureTimeConfigurationState
  stopTimeType: DataCaptureTimeConfigType!
}

type DataStore {
  dataStoreId: ID!
  description: String
  homeDirectoryId: String
  name: String!
  ownerUserId: ID
}

type DataStoreDirectory {
  contents: [DataStoreObject]
  dataStoreDirectoryId: ID!
  dataStoreId: ID
  homeDirectory: Boolean
  name: String!
  #  owner: User
  ownerUserId: ID
  # # positionIndex: Int ## Lower priority
  parentDirectoryId: ID
}

type DataStoreFile {
  contentType: String
  dataStoreDirectoryId: ID
  dataStoreFileId: ID!
  dataStoreId: ID
  dataViewIds: [ID]
  description: String
  fileExtension: String
  lastModified: String
  # # The directory the file resides
  name: String!
  #  owner: User
  ownerUserId: ID
  s3ConfirmedUpload: Boolean
  storageSizeBytes: Int
}

type DataStoreObject {
  dataStoreDirectory: DataStoreDirectory
  dataStoreFile: DataStoreFile
  objectType: DataStoreObjectType!
}

type DigitalTwinModel {
  description: String
  displayName: String!
  dtmi: ID!
  modelId: ID!
  ownerUserId: ID!
  properties: [ModelProperty]
  telemetry: [ModelTelemetry]
}

type EndpointLastValues {
  iotEndpointId: ID!
  telemetryValues: [EndpointTelemetryDataRecord]
}

type EndpointProperty {
  attributeType: ModelAttributeType!
  defaultValue: String
  description: String
  name: String!
  schemaType: ModelSchemaType!
  timestamp: String
  value: String
  writable: Boolean
}

type EndpointTelemetryDataRecord {
  telemetryModel: ModelTelemetry
  timestamp: String
  value: String
}

type GenerateQueryResultExport {
  fileFormat: ExportFileFormat
  queryId: String!
}

type GenerateQueryResultExportFileResult {
  fileFormat: TimeSeriesQueryOutputFileType
  queryId: String!
  timeSeriesDbId: ID!
}

type IotAttributeValue {
  name: String
  schemaType: String
  value: String
}

type IotDataRecord {
  # timeUnit: TimeUnit!
  #recordVersion: Int
  attributes: [IotAttributeValue]
  iotEndpointId: ID
  timestamp: String
}

type IotDataRecordError {
  errorMessage: String!
  errorType: IotDataRecordErrorType!
}

type IotDataRecordWithErrors {
  errors: [IotDataRecordError]!
  record: IotDataRecord!
}

type IotEndpoint {
  description: String
  iotEndpointId: ID!
  iotHubId: ID!
  modelId: ID!
  name: String!
  ownerUserId: ID!
  properties: [EndpointProperty]
  telemetry: [ModelTelemetry]
}

type IotEndpointData {
  includedAttributeNames: [String]!
  iotEndpointId: ID!
  records: [IotDataRecord]
}

type IotEndpointGroup {
  description: String
  endpoints: [IotEndpoint]
  iotEndpointIds: [String]
  iotGroupId: ID!
  iotHubId: ID!
  name: String!
  ownerUserId: ID!
}

type IotEndpointsLastValuesQueryResult {
  clientToken: String!
  data: [EndpointLastValues]!
  nextToken: String
  presignedUrl: String
  queryId: String
  resultChunkIndex: String
  resultStoredInS3: Boolean!
}

type IotHub {
  description: String
  iotHubId: ID!
  name: String!
  ownerUserId: ID!
}

type IotQueryByTimeRangeResult {
  clientToken: String!
  endTime: String!
  nextToken: String
  presignedUrl: String
  queryId: String!
  queryString: String!
  resultChunkIndex: String
  #  data: [IotEndpointData]
  startTime: String!
}

type IotQueryExport {
  fileFormat: ExportFileFormat!
  fileSizeBytes: Int
  queryId: String!
  url: String!
}

type MeasureValue {
  Name: String!
  Type: MeasureValueType!
  Value: String!
}

type ModelAttribute {
  attributeType: ModelAttributeType!
  defaultValue: String
  description: String
  name: String!
  schemaType: ModelSchemaType!
  writable: Boolean
}

type ModelProperty {
  attributeType: ModelAttributeType!
  defaultValue: String
  description: String
  # # Only set if attributeType = Property
  index: Int
  name: String!
  schemaType: ModelSchemaType!
  writable: Boolean
}

type ModelTelemetry {
  attributeType: ModelAttributeType!
  description: String
  index: Int
  name: String!
  schemaType: ModelSchemaType!
}

# # MUTATIONS
type Mutation {
  #  timeSeriesDb_updateDatabaseRecords(
  #   timeSeriesDbId: ID!
  #   data: TimeSeriesDbDataInput!
  # ): TimeSeriesDb
  collaborative_addServiceToCollaborative(
    collaborativeId: ID!
    serviceId: ID!
    serviceType: ServiceType!
  ): Service
  collaborative_removeServiceFromCollaborative(
    collaborativeId: ID!
    serviceId: ID!
    serviceType: ServiceType!
  ): Service
  collaborative_updateCollaborativeMemberOrganization(
    collaborativeId: ID!
    memberState: CollaborativeMemberOrganizationState!
    organizationId: ID!
  ): CollaborativeMemberOrganization
  dataCapture_attachFile(
    captureId: ID!
    description: String
    fileName: String!
  ): PresignedUrl
  dataCapture_createCapture(
    captureType: DataCaptureType!
    description: String
    displayName: String!
  ): DataCapture
  dataCapture_deleteAttachment(
    attachmentId: ID!
    captureId: ID!
  ): DataCaptureAttachment
  dataCapture_deleteCapture(captureId: ID!): DataCapture
  dataCapture_handleCompletion(captureId: ID!): DataCapture
  dataCapture_notifyCaptureComplete(captureId: ID!): DataCapture
  dataCapture_publishData(
    captureId: ID!
    data: [DataCaptureDataRecordInput]!
  ): DataCapturePublishDataResponse
  dataCapture_regenerateAuthenticationToken(captureId: ID!): AuthenticationToken
  dataCapture_startCapture(captureId: ID!): DataCapture
  dataCapture_stopCapture(captureId: ID!): DataCapture
  dataCapture_updateCapture(
    captureId: ID!
    description: String
    displayName: String
    scheduledStartTime: String
    scheduledStopTime: String
    startTimeType: DataCaptureTimeConfigType
    stopTimeType: DataCaptureTimeConfigType
    updateDescription: Boolean!
    updateDisplayName: Boolean!
    updateScheduledStartTime: Boolean!
    updateScheduledStopTime: Boolean!
    updateStartTimeType: Boolean!
    updateStopTimeType: Boolean!
  ): DataCapture
  dataCapture_updateDataModel(
    captureId: ID!
    dataModel: DataCaptureDataModelInput!
  ): DataCaptureDataModel
  iot_addEndpointsToGroup(
    iotEndpointIds: [ID]!
    iotGroupId: ID!
  ): IotEndpointGroup
  iot_cancelQuery(queryId: ID!): ServerResponse
  iot_createEndpoint(
    description: String
    iotHubId: ID!
    modelId: ID!
    name: String!
  ): IotEndpoint
  #  iot_updateDataRecordValues(
  #   iotEndpointId: ID!
  #   data: IotDataRecordInput!
  # ): PublishIotDataResult
  iot_createGroup(
    description: String
    iotEndpointIds: [ID]
    iotHubId: ID!
    name: String!
  ): IotEndpointGroup
  iot_createHub(description: String, name: String!): IotHub
  iot_createModel(
    description: String
    displayName: String!
    dtmiSegment: String!
    properties: [ModelPropertyInput]
    telemetry: [ModelTelemetryInput]
  ): DigitalTwinModel
  iot_createNewModelVersion(
    description: String
    displayName: String
    modelId: ID!
    properties: [ModelPropertyInput]
    telemetry: [ModelTelemetryInput]
    version: Int
  ): DigitalTwinModel
  iot_deleteEndpoint(iotEndpointId: ID!): IotEndpoint
  iot_deleteGroup(iotGroupId: ID!): IotEndpointGroup
  iot_deleteHub(iotHubId: ID!): IotHub
  iot_deleteModel(modelId: ID!): DigitalTwinModel
  iot_generateQueryResultExport(
    fileFormat: ExportFileFormat
    queryId: ID!
  ): GenerateQueryResultExport
  iot_notifyQueryExportComplete(
    fileFormat: ExportFileFormat
    queryId: String!
  ): IotQueryExport
  iot_publish(
    data: [IotDataRecordInput]!
    iotEndpointId: ID!
  ): PublishIotDataResult
  iot_regenerateEndpointToken(iotEndpointId: ID!): AuthenticationToken
  iot_removeEndpointsFromGroup(
    iotEndpointIds: [ID]!
    iotGroupId: ID!
  ): IotEndpointGroup
  iot_updateEndpoint(
    description: String
    iotEndpointId: ID!
    name: String
  ): IotEndpoint
  iot_updateEndpointProperties(
    iotEndpointId: ID!
    properties: [EndpointPropertyInput]!
  ): IotEndpoint
  iot_updateGroup(
    description: String
    iotGroupId: ID!
    name: String
  ): IotEndpointGroup
  iot_updateHub(description: String, iotHubId: ID!, name: String): IotHub
  iot_updateModel(
    description: String
    displayName: String
    dtmiSegment: String
    modelId: ID!
  ): DigitalTwinModel
  iot_updateModelUsedByEndpoint(iotEndpointId: ID!, modelId: ID!): IotEndpoint
  notifications_notifyUploadComplete(uploadId: ID!): UploadCompleteResponse
  platformAdmin_addCollaborativeMember(
    collaborativeId: ID!
    permission: CollaborativeMemberPermission
    userId: ID!
  ): Collaborative
  # # NOTE: ONLY ALLOW DELETE OF ORGANIZATION IF NO USERS ARE ASSOCIATED
  ## COLLABORATIVE MUTATIONS
  platformAdmin_createCollaborative(
    description: String
    name: String!
  ): Collaborative
  # # ORGANIZATION MUTATIONS
  platformAdmin_createOrganization(
    hostOrganization: Boolean
    name: String!
  ): Organization
  platformAdmin_createUser(
    email: String!
    firstName: String!
    lastName: String!
    mobile: String
    organizationId: ID!
    userRoles: [UserRole!]
  ): User
  platformAdmin_deleteCollaborative(
    collaborativeId: ID!
    comment: String
  ): Collaborative
  platformAdmin_deleteOrganization(
    comment: String
    organizationId: ID!
  ): Organization
  platformAdmin_deleteUser(userId: ID!): User
  platformAdmin_deleteUsersCollaboratives(userId: ID!): [Collaborative]
  platformAdmin_deleteUsersServices(userId: ID!): [Service]
  platformAdmin_migrateUsersCollaborativesOwnership(
    currentOwnerUserId: ID!
    transferToUserId: ID!
  ): [Collaborative]
  platformAdmin_migrateUsersServicesOwnership(
    currentOwnerUserId: ID!
    transferToUserId: ID!
  ): [Service]
  platformAdmin_removeCollaborativeMember(
    collaborativeId: ID!
    userId: ID!
  ): Collaborative
  platformAdmin_resendUserInvitation(userId: ID!): User
  platformAdmin_updateCollaborative(
    collaborativeId: ID!
    description: String
    name: String
  ): Collaborative
  platformAdmin_updateCollaborativeMember(
    collaborativeId: ID!
    permission: CollaborativeMemberPermission!
    userId: ID!
  ): Collaborative
  platformAdmin_updateOrganization(
    name: String
    organizationId: ID!
  ): Organization
  platformAdmin_updateUser(
    firstName: String
    lastName: String
    userAccountState: UserAccountState
    userId: ID!
    userRoles: [UserRole]
  ): User
  storage_createDataStore(description: String, name: String!): DataStore
  storage_createDataStoreDirectory(
    dataStoreId: ID!
    name: String!
    parentDirectoryId: ID!
  ): DataStoreDirectory
  storage_createDataStoreFile(
    dataStoreDirectoryId: ID!
    dataStoreId: ID!
    description: String
    fileExtension: String!
    name: String!
  ): PresignedUrl
  storage_createDataStoreFileDataView(dataStoreFileId: ID!): DataStoreFile
  storage_deleteDataStore(dataStoreId: ID!): DataStore
  storage_deleteDataStoreDirectory(
    dataStoreDirectoryId: ID!
  ): DataStoreDirectory
  storage_deleteDataStoreFile(dataStoreFileId: ID!): DataStoreFile
  storage_deleteDataStoreFileDataView(
    dataStoreFileId: ID!
    dataViewId: ID!
  ): DataStoreFile
  storage_updateDataStore(
    dataStoreId: ID!
    description: String
    name: String
  ): DataStore
  storage_updateDataStoreDirectory(
    dataStoreDirectoryId: ID!
    name: String
    parentDirectoryId: ID
  ): DataStoreDirectory
  storage_updateDataStoreFile(
    dataStoreDirectoryId: ID
    dataStoreFileId: ID!
    description: String
    name: String
  ): DataStoreFile
  timeSeriesDb_cancelDatabaseQuery(
    queryId: String!
    timeSeriesDbId: ID!
  ): ServerResponse
  timeSeriesDb_createDatabase(description: String, name: String!): TimeSeriesDb
  timeSeriesDb_deleteDatabase(timeSeriesDbId: ID!): TimeSeriesDb
  timeSeriesDb_generateQueryResultExportFile(
    fileFormat: TimeSeriesQueryOutputFileType
    queryId: String!
    timeSeriesDbId: ID!
  ): GenerateQueryResultExportFileResult
  timeSeriesDb_notifyTimeSeriesQueryExportComplete(
    fileFormat: TimeSeriesQueryOutputFileType
    queryId: String!
  ): TimeSeriesQueryExport
  timeSeriesDb_publishToDatabase(
    assetId: ID!
    data: TimeSeriesDbDataInput!
    timeSeriesDbId: ID!
  ): [TimeSeriesDbAssetData]
  timeSeriesDb_updateDatabase(
    description: String
    name: String
    timeSeriesDbId: ID!
  ): TimeSeriesDb
  # # USER MUTATIONS
  user_createAuthenticationToken(
    daysBeforeExpiration: Int!
    name: String!
  ): AuthenticationToken
  user_deleteAuthenticationToken(tokenId: ID!): AuthenticationToken
}

type OcsAdapter {
  ocsAdapterId: ID!
}

type Organization {
  hostOrganization: Boolean
  name: String!
  organizationId: ID!
}

type PaginatedCaptures {
  captures: [DataCapture]
  nextToken: String
}

type PresignedUrl {
  itemId: ID
  # # the presigned url
  uploadId: ID
  url: String
}

type PublishIotDataResult {
  failedRecords: [IotDataRecordWithErrors]
  recordsWritten: [IotDataRecord]
}

# # QUERIES
type Query {
  # # Lists all collaboratives the user owns or is a member of
  collaborative_getCollaborative(collaborativeId: ID!): Collaborative
  collaborative_listCollaborativeMemberOrganizationRequests(
    collaborativeId: ID
    includeApprovedRequests: Boolean
    includeDeniedRequests: Boolean
  ): [Collaborative]
  collaborative_listCollaborativeServices(collaborativeId: ID!): [Service]
  collaborative_listCollaboratives: [Collaborative]
  collaborative_listCollaborativesServiceSharedWith(
    serviceId: ID!
    serviceType: ServiceType!
  ): [Collaborative]
  dataCapture_getActiveCaptureDataExportDownloadUrl(
    captureId: ID!
  ): DataCaptureDataExport
  dataCapture_getCapture(captureId: ID!, includeDataModel: Boolean): DataCapture
  dataCapture_getCaptureAuthenticationToken(captureId: ID!): AuthenticationToken
  dataCapture_getDataExportDownloadUrl(captureId: ID!): DataCaptureDataExport
  dataCapture_getDataModel(captureId: ID!): DataCaptureDataModel
  dataCapture_getDataModelExport(captureId: ID!): DataCaptureDataModelExport
  dataCapture_getFileAttachmentDownloadUrl(
    attachmentId: ID!
    captureId: ID!
  ): PresignedUrl
  dataCapture_getPythonSDKSample(captureId: ID!): String
  dataCapture_listAttachments(
    captureId: ID!
    limit: Int
    nextToken: String
  ): [DataCaptureAttachment]
  dataCapture_listCaptures(
    includeDataModels: Boolean
    limit: Int
    nextToken: String
  ): PaginatedCaptures
  iot_getEndpoint(iotEndpointId: ID!): IotEndpoint
  iot_getEndpointToken(iotEndpointId: ID!): AuthenticationToken
  iot_getGroup(includeEndpoints: Boolean, iotGroupId: ID!): IotEndpointGroup
  iot_getHub(iotHubId: ID!): IotHub
  iot_getModel(modelId: ID!): DigitalTwinModel
  iot_getModelInDTDLFormat(modelId: ID!): String
  iot_listEndpointLastValues(
    clientToken: String
    iotEndpointId: ID!
    nextToken: String
    queryId: String
    queryString: String
  ): IotEndpointsLastValuesQueryResult
  iot_listEndpointsInHub(iotHubId: ID!): [IotEndpoint]
  iot_listGroups(includeEndpoints: Boolean, iotHubId: ID!): [IotEndpointGroup]
  iot_listGroupsEndpointsLastValues(
    clientToken: String
    iotGroupId: ID!
    nextToken: String
    queryId: String
    queryString: String
  ): IotEndpointsLastValuesQueryResult
  iot_listHubs: [IotHub]
  iot_listHubsEndpointsLastValues(
    clientToken: String
    iotHubId: ID!
    nextToken: String
    queryId: String
    queryString: String
  ): IotEndpointsLastValuesQueryResult
  iot_listModels: [DigitalTwinModel]
  iot_queryByTimeRange(
    clientToken: String
    endTime: String!
    endpointQueryFilters: [EndpointQueryFilter]!
    nextToken: String
    queryId: String
    queryString: String
    startTime: String!
  ): IotQueryByTimeRangeResult
  # # CONTRACT QUERIES
  platformAdmin_getCollaborative(
    collaborativeId: ID!
    includeMemberOrganizations: Boolean
  ): Collaborative
  # # ORGANIZATION QUERIES
  platformAdmin_getOrganization(organizationId: ID!): Organization
  platformAdmin_getUser(userId: ID!): User
  platformAdmin_listCollaboratives(
    includeMemberOrganizations: Boolean
  ): [Collaborative]
  platformAdmin_listOrganizations: [Organization]
  platformAdmin_listUsers(organizationId: ID): [User]
  storage_getDataStore(dataStoreId: ID!): DataStore
  storage_getDataStoreDirectory(dataStoreDirectoryId: ID!): DataStoreDirectory
  storage_getDataStoreFile(dataStoreFileId: ID!): DataStoreFile
  storage_getDataStoreFileDownloadUrl(dataStoreFileId: ID!): PresignedUrl
  storage_getDataStoreZipDownloadUrl(
    dataStoreObjectIds: [DataStoreObjectIdInput]!
  ): PresignedUrl
  storage_listDataStores(organizationId: ID, userId: ID): [DataStore]
  timeSeriesDb_getDatabase(timeSeriesDbId: ID!): TimeSeriesDb
  timeSeriesDb_listAllAssetLastValues(
    clientToken: String
    nextToken: String
    timeSeriesDbId: ID!
  ): TimeSeriesLastValuesQueryResult
  timeSeriesDb_listDatabases: [TimeSeriesDb]
  timeSeriesDb_queryDatabase(
    assets: [TimeSeriesQueryAssetInput]!
    clientToken: String
    endTime: String
    maxRows: Int
    nextToken: String
    queryString: String
    queryType: TimeSeriesDbQueryType!
    startTime: String
    timeSeriesDbId: ID!
  ): TimeSeriesQueryResult
  timeSeriesDb_queryDatabaseWithTimestreamQuery(
    clientToken: String
    maxRows: Int
    nextToken: String
    queryString: String!
    timeSeriesDbId: ID!
  ): AWSTimestreamQueryResult
  # # USER QUERIES
  user_getUserSession: UserSession
  user_listAuthenticationTokens: [AuthenticationToken]
}

type S3Object {
  key: String
  mimeType: String
  region: String
  uploadUrl: String
  url: String
}

type Schema {
  mutation: Mutation
  query: Query
}

type ServerResponse {
  errorMessage: String
  httpStatusCode: Int
}

type Service {
  dataCapture: DataCapture
  dataStore: DataStore
  iotEndpointGroup: IotEndpointGroup
  ocsAdapter: OcsAdapter
  # # Depending on type - the corresponding entry below will contain the object and data
  serviceId: ID!
  serviceType: ServiceType!
  timeSeriesDb: TimeSeriesDb
}

# # SUBSCRIPTIONS (NOTE: RETURN TYPE MUST INCLUDE THE PARAMETER TO FILTER IN ORDER TO FIRE THE SUBSCRIPTION)
type Subscription {
  onCapturePublishData(captureId: ID!): DataCapturePublishDataResponse
  onIotPublish(iotEndpointId: ID!): PublishIotDataResult
  onNotifyCaptureComplete(captureId: ID!): DataCapture
  onNotifyIotQueryExportComplete(queryId: String!): IotQueryExport
  onNotifyTimeSeriesQueryExportComplete(queryId: String!): TimeSeriesQueryExport
  onNotifyUploadComplete(uploadId: ID!): UploadCompleteResponse
  onStartCapture(captureId: ID!): DataCapture
  onStopCapture(captureId: ID!): DataCapture
  onTimeSeriesDbPublish(
    assetId: ID!
    timeSeriesDbId: ID!
  ): [TimeSeriesDbAssetData]
}

type TimeSeriesAsset {
  assetId: ID!
  attributes: [TimeSeriesAssetAttribute]
}

type TimeSeriesAssetAttribute {
  assetId: ID!
  measureName: String!
  measureType: String!
  measureValue: String
}

type TimeSeriesDb {
  databaseName: String
  description: String
  name: String!
  ownerUserId: ID!
  tableName: String
  timeSeriesDbId: ID!
}

type TimeSeriesDbAssetData {
  assetId: ID!
  attributes: [AssetAttribute]
  name: String
}

type TimeSeriesDbCommonAttributes {
  MeasureName: String
  # # MeasureValueType must be MULTI for multiple values
  MeasureValueType: MeasureValueTypeMULTI
  MeasureValues: [MeasureValue]
  Time: String
  TimeUnit: TimeUnit
  Version: Int
  dimensions: [TimeSeriesDbDimension]
}

type TimeSeriesDbData {
  # # commonAttributes: TimeSeriesDbCommonAttributes
  records: [TimeSeriesDbRecord]!
}

type TimeSeriesDbDimension {
  dimensionValueType: DimensionValueType
  # # Only VARCHAR allowed
  name: String!
  value: String!
}

type TimeSeriesDbRecord {
  Dimensions: [TimeSeriesDbDimension]
  MeasureName: String
  MeasureValue: String
  # # MeasureValueType must be MULTI for multiple values
  MeasureValueType: MeasureValueType
  MeasureValues: [MeasureValue]
  Time: String
  TimeUnit: TimeUnit
  Version: Int
}

type TimeSeriesLastValuesQueryResult {
  clientToken: String
  # # 0.0 - 100.0
  data: [TimeSeriesDbAssetData]!
  nextToken: String
  queryId: String!
  queryProgressPercentage: Float!
  resultChunkIndex: Int
}

type TimeSeriesQueryExport {
  fileSizeBytes: Int
  fileType: TimeSeriesQueryOutputFileType!
  queryId: String!
  url: String!
}

type TimeSeriesQueryResult {
  # # 0.0 - 100.0
  #data: [TimeSeriesDbAssetData]!
  clientToken: String
  nextToken: String
  presignedUrl: String
  queryId: String!
  queryProgressPercentage: Float!
  queryString: String
  resultChunkIndex: Int
}

type UploadCompleteResponse {
  errorMessage: String
  httpStatusCode: Int
  uploadId: ID!
}

# # TYPES
type User {
  email: String
  firstName: String
  lastActive: String
  lastName: String
  mobile: String
  organization: Organization
  userAccountState: UserAccountState
  userId: ID!
  userRoles: [UserRole]
}

type UserSession {
  user: User
}

enum AuthenticationTokenType {
  DATA_CAPTURE_READ_WRITE
  IOT_ENDPOINT_READ_WRITE
  USER_FULL_ACCESS
}

enum CaptureSortBy {
  DATE_CREATED
  NAME
  STATE
  TYPE
}

enum CollaborativeMemberOrganizationState {
  APPROVED
  DENIED_ACCESS
  HOST_ORGANIZATION
  PENDING_APPROVAL
}

enum CollaborativeMemberPermission {
  READ_ONLY
  READ_WRITE
}

enum DataCaptureAssetAttributeSchemaType {
  boolean
  double
  integer
  string
}

enum DataCaptureAssetAttributeType {
  TELEMETRY
}

enum DataCaptureAttachmentError {
  FILE_UPLOAD_INCOMPLETE
}

enum DataCaptureAttachmentType {
  FILE
}

enum DataCaptureDataExportState {
  COMPLETE
  FAILED
  IN_PROGRESS
  NOT_CREATED
}

enum DataCaptureDataExportType {
  ACTIVE_CAPTURE_EXPORT
  FULL_EXPORT
}

enum DataCaptureDataModelState {
  ERROR
  GOOD
}

enum DataCaptureRecordError {
  InvalidAttributeId
  InvalidTimestamp
  RecordExists
  Unknown
  ValueTypeError
}

enum DataCaptureState {
  CAPTURING
  COMPLETE
  COMPLETION_ERROR
  CONFIGURATION_ERROR
  DELETING
  FINISHING
  READY
}

enum DataCaptureTimeConfigType {
  MANUAL
  SCHEDULED
}

enum DataCaptureTimeConfigurationState {
  ERROR
  GOOD
}

enum DataCaptureType {
  STANDARD
}

enum DataStoreObjectType {
  DIRECTORY
  FILE
}

enum DimensionValueType {
  VARCHAR
}

enum ExportFileFormat {
  CSV
}

enum IotDataRecordErrorType {
  DUPLICATE_ENTRY
  INCORRECT_VALUE_TYPE
  INVALID_TIMESTAMP
  MISSING_DATA
  MISSING_TIME_UNIT
  UNEXPECTED_ATTRIBUTE
  UNKNOWN
}

enum MeasureValueType {
  BIGINT
  BOOLEAN
  DOUBLE
  MULTI
  TIMESTAMP
  VARCHAR
}

enum MeasureValueTypeMULTI {
  MULTI
}

enum ModelAttributeType {
  Property
  Telemetry
}

enum ModelSchemaType {
  boolean
  dateTime
  double
  duration
  integer
  string
}

enum ServiceType {
  DATA_CAPTURE
  DATA_STORE
  IOT_GROUP
  OCS_ADAPTER
  TIME_SERIES_DB
}

enum TimeSeriesDbQueryType {
  LAST_X_ROWS
  NEXT_TOKEN
  TIME_PERIOD
}

enum TimeSeriesQueryOutputFileType {
  CSV
  JSON
}

enum TimeUnit {
  MICROSECONDS
  MILLISECONDS
  NANOSECONDS
  SECONDS
}

# # ENUMS
enum UserAccountState {
  ACTIVE
  DISABLED
  PENDING
}

enum UserRole {
  # access data via digital collaborative
  DATA_COMPLIANCE
  # provision resources, link resources to digital collaborative
  DATA_CONSUMER
  # create digital collaborative, add organizations, add user accounts
  DATA_PROVIDER
  PLATFORM_ADMIN
}

input DataCaptureAssetAttributeInput {
  attributeType: DataCaptureAssetAttributeType!
  description: String
  displayName: String!
  schemaType: DataCaptureAssetAttributeSchemaType!
  unit: String
  userDefinedId: ID!
}

input DataCaptureAssetInput {
  attributes: [DataCaptureAssetAttributeInput]!
  description: String
  displayName: String!
  userDefinedId: ID!
}

input DataCaptureAttributeValueInput {
  userDefinedId: ID!
  value: String!
}

input DataCaptureDataModelInput {
  assets: [DataCaptureAssetInput]!
}

input DataCaptureDataRecordInput {
  # # Epoch milliseconds
  attributeValues: [DataCaptureAttributeValueInput]!
  timestamp: String!
}

input DataStoreObjectIdInput {
  dataStoreDirectoryId: ID
  dataStoreFileId: ID
  objectType: DataStoreObjectType!
}

input EndpointPropertyInput {
  name: String!
  timestamp: String!
  value: String!
}

input EndpointQueryFilter {
  attributeNames: [String]!
  iotEndpointId: ID!
}

input IotAttributeValueInput {
  name: String!
  value: String!
}

input IotDataRecordInput {
  attributes: [IotAttributeValueInput]
  timeUnit: TimeUnit
  timestamp: String
}

input ListCapturesFilterInput {
  sortBy: CaptureSortBy
  state: DataCaptureState
}

input MeasureValueInput {
  Name: String!
  Type: MeasureValueType!
  Value: String!
}

input ModelPropertyInput {
  defaultValue: String
  description: String
  index: Int
  name: String!
  schemaType: ModelSchemaType!
  writable: Boolean
}

input ModelTelemetryInput {
  description: String
  index: Int
  name: String!
  schemaType: ModelSchemaType!
}

# # AWS SPECIFIC TYPES
input S3ObjectInput {
  bucket: String
  key: String
  mimeType: String
  region: String
  uploadUrl: String
  url: String
}

input TimeSeriesDbCommonAttributesInput {
  MeasureName: String
  MeasureValue: String
  # # MeasureValueType must be MULTI for multiple values
  MeasureValueType: MeasureValueType
  MeasureValues: [MeasureValueInput]
  Time: String
  TimeUnit: TimeUnit
  Version: Int
  dimensions: [TimeSeriesDbDimensionInput]
}

# # Mutation input parameters must be defined as "input" rather than "type"
input TimeSeriesDbDataInput {
  # # commonAttributes: TimeSeriesDbCommonAttributesInput
  records: [TimeSeriesDbRecordInput]!
}

input TimeSeriesDbDimensionInput {
  DimensionValueType: DimensionValueType
  # # Only VARCHAR allowed
  Name: String!
  Value: String!
}

input TimeSeriesDbRecordInput {
  Dimensions: [TimeSeriesDbDimensionInput]
  MeasureName: String
  MeasureValue: String
  # # MeasureValueType must be MULTI for multiple values
  MeasureValueType: MeasureValueType
  MeasureValues: [MeasureValueInput]
  Time: String
  TimeUnit: TimeUnit
  Version: Int
}

input TimeSeriesQueryAssetInput {
  assetId: String!
  attributeNamesFilter: [String]
}
